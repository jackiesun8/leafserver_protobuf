package main

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"github.com/jhoonb/archivex"
	"github.com/kardianos/osext"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
)

//功能作用：生成(版本号.zip)包并上传到指定web server
//使用方式：assets-builder -v=0.0.1 -d=res,src -s=http://192.168.0.134:8080/uploadfile
//机制说明：
//1.检查版本号.zip文件是否已存在，如果存在，终止流程
//2.遍历目录的文件，计算MD5并与.CHECKSUM(JSON格式)记录的相比较，如果有变动，加入变动列表
//2.1如果遇到一个新的文件（一个文件的MD5在.CHECKSUM中不存在），则计算MD5并加入到.CHECKSUM，同时加入到变动列表
//2.2如果一个文件改名，则当新文件处理
//2.3因为以上规则，旧文件将冗余不再处理
//3.使用zip打包变动列表文件(如无变动，则不生成zip打包文件)
//4.上传zip打包文件到指定web server

func exist(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil || os.IsExist(err)
}

// Creates a new file upload http request with optional extra params
func newfileUploadRequest(uri string, params map[string]string, paramName, path string) (*http.Request, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile(paramName, filepath.Base(path))
	if err != nil {
		return nil, err
	}
	_, err = io.Copy(part, file)

	for key, val := range params {
		_ = writer.WriteField(key, val)
	}
	err = writer.Close()
	if err != nil {
		return nil, err
	}
	req, _ := http.NewRequest("POST", uri, body)
	req.Header.Add("Content-Type", writer.FormDataContentType())
	return req, nil
}

func main() {
	//获取可执行文件所在的绝对路径
	//不同于用户当前shell所在的目录
	curDir, _ := osext.ExecutableFolder()
	fmt.Println("current directory :", curDir)

	//解析参数
	version := flag.String("v", "0.0.1", "version number")
	dir := flag.String("d", "res,src", "directory to walk")
	server := flag.String("s", "http://192.168.0.134:8080/uploadfile", "web server address to upload")

	flag.Parse()

	//检查zip文件是否已存在
	version_name := strings.Replace(*version, ".", "_", -1)
	if exist(version_name + ".zip") {
		panic(errors.New("already exist zip file : " + version_name + ".zip"))
	}

	fmt.Println("version number :", *version)
	fmt.Println("directory to walk :", *dir)
	fmt.Println("web server address to upload :", *server)

	//md5校验和表
	checksum_table := make(map[string]string)
	f, err := os.OpenFile(path.Join(curDir, "CHECKSUM"), os.O_CREATE|os.O_APPEND|os.O_RDWR, 0660)
	if err != nil {
		panic(err)
	}

	//zip打包表
	zip_table := make([]string, 0, 100)

	defer func() {
		json_data, err := json.Marshal(checksum_table)
		if err != nil {
			panic(err)
		}
		f.Close()
		ioutil.WriteFile(path.Join(curDir, "CHECKSUM"), json_data, 0660)
		if len(zip_table) != 0 {
			//打包
			zip := new(archivex.ZipFile)
			zip.Create(path.Join(curDir, version_name+".zip"))
			for _, v := range zip_table {
				zip.AddFile(v)
			}
			zip.Close()
			//上传
			extraParams := map[string]string{
				"title":       "Zip File",
				"author":      "Jackie Sun",
				"description": "A zip file that generated by assets-builder",
			}
			request, err := newfileUploadRequest(*server, extraParams, "file", path.Join(curDir, version_name+".zip"))
			if err != nil {
				log.Fatal(err)
			}
			client := &http.Client{}
			resp, err := client.Do(request)
			if err != nil {
				log.Fatal(err)
			} else {
				body := &bytes.Buffer{}
				_, err := body.ReadFrom(resp.Body)
				if err != nil {
					log.Fatal(err)
				}
				resp.Body.Close()
				//fmt.Println(resp.StatusCode)
				//fmt.Println(resp.Header)
				fmt.Print(body)
			}
		} else {
			fmt.Println("nothing to zip")
		}
	}()
	//校验和文件源数据
	checksum_data, err := ioutil.ReadAll(f)
	if len(checksum_data) != 0 {
		//fmt.Println("Unmarshal CHECKSUM")
		err = json.Unmarshal(checksum_data, &checksum_table)
		if err != nil {
			panic(err)
		}
		//fmt.Printf("%#v\n", checksum_table)
	}

	for _, v := range strings.Split(*dir, ",") {
		walkDir := path.Join(curDir, v)
		//fmt.Println("---------- Walking directory :", walkDir, "----------")
		filepath.Walk(walkDir,
			func(path string, f os.FileInfo, err error) error {
				if f == nil {
					fmt.Println("FileInfo of path:", path, "is nil")
					return err
				}
				if f.IsDir() {
					return nil
				}
				//fmt.Println(path)
				//读取文件数据
				file_data, err := ioutil.ReadFile(path)
				if err != nil {
					panic(err)
				}
				//fmt.Println(file_data)
				//计算md5校验和
				h := md5.New()
				h.Write(file_data)
				checksum := hex.EncodeToString(h.Sum(nil))
				//fmt.Println(checksum)
				if v, ok := checksum_table[path]; ok {
					if v == checksum {
						return nil
					} else {
						zip_table = append(zip_table, strings.TrimPrefix(path, curDir+string(rune(filepath.Separator))))
					}
				} else {
					zip_table = append(zip_table, strings.TrimPrefix(path, curDir+string(rune(filepath.Separator))))
				}
				checksum_table[path] = checksum
				return nil
			})
		//fmt.Println("---------- Leaving directory :", walkDir, "----------")
	}
}
